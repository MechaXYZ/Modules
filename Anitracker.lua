--[[
	mech's anitracker
	i know i suck at names

	how to use:
	1. create a new track with AnimationTrack.new()
	2. anim:setAnimation(url or table)
	3. anim:setRig(rig)
	4. anim:Play()

	- example code
	local AnimationTrack = require(path.to.module) -- // or alternatively, (for the noobs), loadstring(game:GetService("HttpService"):GetAsync("https://github.com/MechaXYZ/modules/raw/main/Anitracker.lua"))()
	local anims = require(path.to.anim)

	-- // can pass an url too
	-- // local anims = "https://rentry.co/anitracker_example/raw"

	local anim = AnimationTrack.new()
	anim:setAnimation(anims)
	anim:setRig(owner.Character)
	anim:Play()

	- custom function that adds root motion
	- works best when rootpart is anchored
	- uses a bodyvelocity named RootMotionVelocity for movement when unanchored (really shitty)
	
	- can be used by calling anim:addRootMotion(name of part connected to root part, e.g. Torso)

	- AdjustWeight doesn't actually adjust weight, it adjusts priority (i thought weights and priority were the same thing a while back)
	- set anim.lerpFactor to change how much it lerps into the next pose
	- AnimationTrack.NoDisableTransition is global and sets whether the welds lerp into their parent's Transform after all animations on a rig are done playing before being disabled, setting it to false disables the welds as soon as the last animation stops
	- AutoDisableWelds is also a global, that, as its name suggests, toggles whether welds are automatically disabled when the last animation stops
	- welds generated by anitracker are named AWeld with an attribute called AnitrackerEnabled set to true, disable the welds before setting the attribute to false
	- can also be used on client
]]

-- // Signal by sleitnick (edited for lua 5.1)
local SignalClass

do
	local freeRunnerThread = nil

	local function acquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquiredRunnerThread = freeRunnerThread
		freeRunnerThread = nil
		fn(...)

		freeRunnerThread = acquiredRunnerThread
	end

	local function runEventHandlerInFreeThread(...)
		acquireRunnerThreadAndCallEventHandler(...)

		while true do
			acquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	function Connection:Disconnect()
		if not self.Connected then
			return
		end

		self.Connected = false

		if self._signal._handlerListHead == self then
			self._signal._handlerListHead = self._next
		else
			local prev = self._signal._handlerListHead

			while prev and prev._next ~= self do
				prev = prev._next
			end

			if prev then
				prev._next = self._next
			end
		end
	end

	Connection.Destroy = Connection.Disconnect

	setmetatable(Connection, {
		__index = function(_tb, key)
			error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
		__newindex = function(_tb, key, _value)
			error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
	})

	local Signal = {}
	Signal.__index = Signal

	function Signal.new()
		local self = setmetatable({
			_handlerListHead = false,
			_proxyHandler = nil,
			_yieldedThreads = nil,
		}, Signal)

		return self
	end

	function Signal.Wrap(rbxScriptSignal)
		assert(
			typeof(rbxScriptSignal) == "RBXScriptSignal",
			"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
		)

		local signal = Signal.new()

		signal._proxyHandler = rbxScriptSignal:Connect(function(...)
			signal:Fire(...)
		end)

		return signal
	end

	function Signal.Is(obj)
		return type(obj) == "table" and getmetatable(obj) == Signal
	end

	function Signal:Connect(fn)
		local connection = setmetatable({
			Connected = true,
			_signal = self,
			_fn = fn,
			_next = false,
		}, Connection)

		if self._handlerListHead then
			connection._next = self._handlerListHead
			self._handlerListHead = connection
		else
			self._handlerListHead = connection
		end

		return connection
	end

	function Signal:ConnectOnce(fn)
		return self:Once(fn)
	end

	function Signal:Once(fn)
		local connection
		local done = false

		connection = self:Connect(function(...)
			if done then
				return
			end

			done = true
			connection:Disconnect()
			fn(...)
		end)

		return connection
	end

	function Signal:GetConnections()
		local items = {}

		local item = self._handlerListHead

		while item do
			table.insert(items, item)
			item = item._next
		end

		return items
	end

	function Signal:DisconnectAll()
		local item = self._handlerListHead

		while item do
			item.Connected = false
			item = item._next
		end

		self._handlerListHead = false

		local yieldedThreads = rawget(self, "_yieldedThreads")

		if yieldedThreads then
			for thread in pairs(yieldedThreads) do
				if coroutine.status(thread) == "suspended" then
					warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
					task.cancel(thread)
				end
			end

			table.clear(self._yieldedThreads)
		end
	end

	function Signal:Fire(...)
		local item = self._handlerListHead
		while item do
			if item.Connected then
				if not freeRunnerThread then
					freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				end
				task.spawn(freeRunnerThread, item._fn, ...)
			end
			item = item._next
		end
	end

	function Signal:FireDeferred(...)
		local item = self._handlerListHead

		while item do
			local conn = item

			task.defer(function(...)
				if conn.Connected then
					conn._fn(...)
				end
			end, ...)

			item = item._next
		end
	end

	function Signal:Wait()
		local yieldedThreads = rawget(self, "_yieldedThreads")
		if not yieldedThreads then
			yieldedThreads = {}
			rawset(self, "_yieldedThreads", yieldedThreads)
		end

		local thread = coroutine.running()
		yieldedThreads[thread] = true

		self:Once(function(...)
			yieldedThreads[thread] = nil
			task.spawn(thread, ...)
		end)

		return coroutine.yield()
	end

	function Signal:Destroy()
		self:DisconnectAll()

		local proxyHandler = rawget(self, "_proxyHandler")
		if proxyHandler then
			proxyHandler:Disconnect()
		end
	end

	setmetatable(Signal, {
		__index = function(_tb, key)
			error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
		end,
		__newindex = function(_tb, key, _value)
			error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
		end,
	})

	SignalClass = table.freeze({
		new = Signal.new,
		Wrap = Signal.Wrap,
		Is = Signal.Is,
	})
end

local AnimationTrack
local ins_thres = .006
local twait = task.wait
local Signal = SignalClass
local http = game:GetService("HttpService")
local tween = game:GetService("TweenService")

-- // optimizations
local find = table.find
local clear = table.clear
local insert = table.insert
local min, max = math.min, math.max

do
	AnimationTrack = {}
	AnimationTrack.Rigs = {}
	AnimationTrack.Speed = 1
	AnimationTrack.Stall = 0
	AnimationTrack.Length = 0
	AnimationTrack.Weight = 1
	AnimationTrack.Looped = false
	AnimationTrack.RealWeight = 1
	AnimationTrack.lerpFactor = .6
	AnimationTrack.TimePosition = 0
	AnimationTrack.IsPlaying = false
	AnimationTrack.__index = AnimationTrack
	AnimationTrack.AutoDisableWelds = false
	AnimationTrack.NoDisableTransition = false

	local function enumExists(type, value)
		return pcall(function()
			return Enum[type][value] ~= nil
		end)
	end

	function AnimationTrack.Destroy(self)
		if not self then
			return
		end

		if self.Connections then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end

			clear(self.Connections)
		end

		if self.Binds then
			for _, v in pairs(self.Binds) do
				v:Destroy()
			end

			clear(self.Binds)
		end

		clear(self.Cache)
		clear(self.Used)
		self.Stopped:Destroy()
		self.Stopped = nil

		local stuff = AnimationTrack.Rigs[self.Rig]

		if stuff then
			for i, v in pairs(stuff.Animations) do
				if v == self then
					stuff.Animations[i] = nil
					break
				end
			end
		end

		clear(self)
		self = nil
	end

	function AnimationTrack.new()
		local track = setmetatable({}, AnimationTrack)
		track.Rigs = nil


		track.Used = {}
		track.Cache = {}
		track.Binds = {}
		track.Connections = {}
		track.KeyframeMarkers = {}
		track.Stopped = Signal.new()
		track.DidLoop = Signal.new()
		track.Identifier = http:GenerateGUID()

		return track
	end

	function AnimationTrack.GetMarkerReachedSignal(self, marker)
		if not self.Binds[marker] then
			self.Binds[marker] = Signal.new()
		end

		return self.Binds[marker]
	end

	function AnimationTrack.GetKeyframeReachedSignal(self, keyframe)
		if typeof(keyframe) == "number" then
			local num = keyframe
			keyframe = self.Animation[num]
			assert(keyframe, string.format("Keyframe #%d does not exist!", num))
		end

		assert(find(self.Animation, keyframe), "Keyframe does not exist!")

		if not self.Binds[keyframe] then
			self.Binds[keyframe] = Signal.new()
		end

		return self.Binds[keyframe]
	end

	function AnimationTrack.AdjustWeight(self, weight)
		self.RealWeight = weight
		self.Weight = self.RealWeight
	end

	function AnimationTrack.addWeld(self, motor)
		local weld = motor:FindFirstChild("AWeld")

		if not weld then
			weld = Instance.new("Weld")
			weld.C0 = motor.C0
			weld.C1 = motor.C1
			weld.Name = "AWeld"
			weld.Part0 = motor.Part0
			weld.Part1 = motor.Part1
			weld.Parent = motor
		end

		weld:SetAttribute("AnitrackerEnabled", true)

		AnimationTrack.Rigs[self.Rig].Welds[motor.Part1.Name] = weld
		AnimationTrack.Rigs[self.Rig].Poses[motor.Part1.Name] = CFrame.identity
	end

	function AnimationTrack.setRig(self, rig)
		assert(self.Animation, "Must set Animation before setting Rig!")
		assert(not self.Rig, "Can only set Rig once!")

		self.Rig = rig

		-- // funny variable name
		local boner = rig:FindFirstChild("InitialPoses")

		if boner then
			local root = rig:FindFirstChildWhichIsA("Bone", true):FindFirstAncestorWhichIsA("BasePart")

			if not root then
				boner = nil
				return
			end

			for _, v in pairs(boner:GetChildren()) do
				if string.find(v.Name, "_Initial") then
					repeat
						local bone = root:FindFirstChild(string.gsub(v.Name, "_Initial", ""), true)

						if not bone then
							break
						end

						bone:SetAttribute("Initial", v.Value)
					until true
				end
			end
		end

		local main = AnimationTrack.Rigs[rig]

		if not main then
			AnimationTrack.Rigs[rig] = {
				Poses = {},
				Welds = {},
				Animations = {self}
			}

			local animate
			main = AnimationTrack.Rigs[rig]

			animate = game:GetService("RunService").PostSimulation:Connect(function(dt)
				if not AnimationTrack.Rigs[rig] then
					animate:Disconnect()
				end

				local allDone = true
				local usedJoints = {}
				local main = AnimationTrack.Rigs[rig]

				for _, v in pairs(main.Animations) do
					if v.IsPlaying then
						allDone = false

						for i in pairs(v.Used) do
							usedJoints[i] = true
						end
					end
				end

				if not boner then
					local honored_one = self:GetPrioritized()

					for i, v in pairs(main.Welds) do
						repeat
							if not v.Parent then
								main.Welds[i] = nil
								break
							end

							local transform = main.Poses[i]

							if honored_one and honored_one.RootMotion == i and v.Enabled and not allDone and usedJoints[i] then
								local root = main.Welds[i].Part0

								--[[
								local f = Instance.new("Part")
								f.Anchored = true
								f.CanQuery = false
								f.CanTouch = false
								f.CanCollide = false
								f.Color = Color3.new(1, 0, 0)
								f.Size = Vector3.new(2, 2, 1)
								f.Material = Enum.Material.Neon
								f.CFrame = root.CFrame * ((v.Parent.C0 * transform)* v.Parent.C1:Inverse())
								f.Parent = script
								game:GetService("TweenService"):Create(f, TweenInfo.new(2), {Transparency = 1}):Play()
								task.delay(2, f.Destroy, f)
								]]

								local delta = honored_one.LastRootTransform:ToObjectSpace(transform)
								local calc = ((v.Parent.C0 * delta) * v.Parent.C1:Inverse())

								honored_one.LastRootTransform = transform

								if root.Anchored then
									-- // honored_one.RootVelocity.MaxForce = Vector3.zero
									root.CFrame = root.CFrame * calc
									transform = CFrame.identity
								--[[
								else
									-- // idk how to fix this

									local x, y, z = calc:ToEulerAnglesXYZ()
									root.CFrame = root.CFrame * CFrame.Angles(0, y, 0)

									local dist = calc.Position.Magnitude
									honored_one.RootVelocity.MaxForce = Vector3.one * 10e7
									
									if dist > 0 then
										honored_one.RootVelocity.Velocity = (root.CFrame * calc).LookVector / dist / dt
									else
										honored_one.RootVelocity.Velocity = Vector3.zero
									end
									
									local x, _, z = transform:ToEulerAnglesXYZ()
									transform = CFrame.Angles(x, 0, z)
								]]
								end
							end

							transform = CFrame.new(transform.Position * rig:GetScale()) * CFrame.Angles(transform:ToEulerAnglesXYZ())

							if AnimationTrack.AutoDisableWelds then
								if not allDone and usedJoints[i] then
									v.Enabled = v:GetAttribute("AnitrackerEnabled")
									v.C0 = v.Parent.C0 * transform
								elseif allDone or not usedJoints[i] then
									if not self.NoDisableTransition then
										v.C0 = v.C0:Lerp(v.Parent.C0 * v.Parent.Transform, self.lerpFactor)

										if (v.C0.Position - (v.Parent.C0 * v.Parent.Transform).Position).Magnitude <= .2 then
											v.Enabled = false

											if main then
												main.Poses[i] = v.Parent.Transform
											end
										end
									else
										v.Enabled = false

										if main then
											main.Poses[i] = v.Parent.Transform
										end
									end
								end
							else
								v.Enabled = v:GetAttribute("AnitrackerEnabled")
								v.C0 = v.Parent.C0 * transform
							end
						until true
					end
				else
					for i, v in pairs(main.Welds) do
						repeat
							if not v:GetAttribute("Initial") then
								main.Welds[i] = nil
								break
							end

							if not allDone then
								v.CFrame = v:GetAttribute("Initial") * main.Poses[i]
							else
								v.CFrame = v:GetAttribute("Initial")

								if main then
									main.Poses[i] = CFrame.identity
								end
							end
						until true
					end
				end
			end)

			local adder

			adder = rig.DescendantAdded:Connect(function(v)
				if not AnimationTrack.Rigs[rig] then
					adder:Disconnect()
				end

				if v:IsA("Motor6D") then
					self:addWeld(v)
				end
			end)

			main.Adder = adder
			main.Animate = animate
		else
			insert(main.Animations, self)
		end

		for _, v in pairs(rig:GetDescendants()) do
			repeat
				if boner and v:IsA("Bone") and self.Used[v.Name] then
					main.Welds[v.Name] = v
					main.Poses[v.Name] = CFrame.identity

					break
				end

				if v:IsA("Motor6D") and self.Used[v.Part1.Name] then
					self:addWeld(v)
				end
			until true
		end

		coroutine.wrap(function()
			repeat
				twait()
			until rig.Parent

			rig.Parent.ChildRemoved:Connect(function(v)
				if v == rig then
					AnimationTrack.Rigs[rig] = nil
					self:Destroy()
				end
			end)
		end)()
	end

	function AnimationTrack.addRootMotion(self, what)
		assert(self.Rig, "Must set Rig before adding Root Motion!")
		assert((not self.RootMotion), "Can only add Root Motion once!")

		-- // local bv = Instance.new("BodyVelocity")
		-- // bv.Name = "RootMotionVelocity"
		-- // bv.MaxForce = Vector3.one * 10e7
		-- // bv.Parent = AnimationTrack.Rigs[self.Rig].Welds[what].Part0

		self.RootMotion = what
		-- // self.RootVelocity = bv

		self.LastRootTransform = CFrame.identity

		self.DidLoop:Connect(function()
			self.LastRootTransform = CFrame.identity
		end)
	end

	function AnimationTrack.getMotor(self, name)
		if self.Cache[name] then
			return self.Cache[name]
		end

		for _, v in pairs(self.Rig:GetDescendants()) do
			if v:IsA("Motor6D") and v.Part1.Name == name then
				self.Cache[name] = v
				return v
			end
		end
	end

	function AnimationTrack.setAnimation(self, anim)
		local length = 0

		if typeof(anim) == "string" then
			if game:GetService("RunService"):IsClient() then
				error("You must be on server to pass urls to setAnimation!")
			end

			anim = loadstring(http:GetAsync(anim))()
		end

		self.Animation = anim

		for i, v in pairs(anim) do
			if v.tm > length then
				length = v.tm
			end

			for j, w in pairs(v) do
				repeat
					if typeof(w) ~= "table" then
						if typeof(w) == "string" then
							insert(self.KeyframeMarkers, {
								Name = j,
								Value = w,
								Time = v.tm
							})
						end

						break
					end

					self.Used[j] = true

					-- // taken from replay
					local o, p = 1, 1

					while true do
						local next = anim[i + o]

						if next and next[j] then
							w.nx = i + o
							break
						end

						o = o + 1

						if (i + o) > #(anim) then
							break
						end
					end

					while true do
						local prev = anim[i - p]

						if prev and prev[j] then
							w.pv = i - p
							break
						end

						p = p + 1

						if (i - p) < 1 then
							break
						end
					end
				until true
			end
		end

		self.Length = length
	end

	function AnimationTrack.GetPrioritized(self)
		local main = AnimationTrack.Rigs[self.Rig]

		if not main or not main.Animations then
			return
		end

		local highest = 0
		local prioritized

		for _, v in pairs(main.Animations) do
			if v.Weight > highest and v.IsPlaying then
				prioritized = v
				highest = v.Weight
			end
		end

		return prioritized
	end

	function AnimationTrack.IsPrioritized(self, j)
		local main = AnimationTrack.Rigs[self.Rig]

		if not main or not main.Animations then
			return
		end

		local highest = 0
		local prioritized

		for _, v in pairs(main.Animations) do
			if v.Weight > highest and v.IsPlaying then
				prioritized = v
				highest = v.Weight
			end
		end

		if prioritized == self then
			return true
		elseif prioritized ~= self and prioritized then
			if not prioritized.Used[j] then
				local second
				local highest = 0

				for _, v in pairs(main.Animations) do
					if v.Weight > highest and v.IsPlaying and v ~= prioritized then
						second = v
						highest = v.Weight
					end
				end

				return second == self
			end
		end
	end

	function AnimationTrack.setCFrame(self, name, cf, info)
		local weld = AnimationTrack.Rigs[self.Rig].Welds[name]
		local poses = AnimationTrack.Rigs[self.Rig].Poses

		if not info then
			AnimationTrack.Rigs[self.Rig].Poses[name] = cf
			weld.C0 = weld.Parent.C0 * cf
		else
			local start = tick()

			while (tick() - start) < info.Time and AnimationTrack.Rigs[self.Rig] and AnimationTrack.Rigs[self.Rig].Poses do
				poses[name] = poses[name]:Lerp(
					cf,
					tween:GetValue((tick() - start) / info.Time, info.EasingStyle, info.EasingDirection)
				)

				weld.C0 = weld.Parent.C0 * poses[name]
				twait()
			end
		end
	end

	function AnimationTrack.goToKeyframe(self, v, inst)
		local speed = self.Speed

		if self.Binds[v] then
			self.Binds[v]:Fire()
		end

		for j, w in pairs(v) do
			local br = false

			repeat
				if typeof(w) ~= "table" or not AnimationTrack.Rigs[self.Rig].Poses[j] then
					if typeof(w) == "string" and self.Binds[j] then
						self.Binds[j]:Fire(w)
					end

					break
				end

				if not AnimationTrack.Rigs[self.Rig].Animations then
					br = true
					break
				end

				local tm = .1
				local nx = w.nx
				local cf = w.cf
				local poses = AnimationTrack.Rigs[self.Rig].Poses

				if nx then
					cf = self.Animation[w.nx][j].cf
					tm = self.Animation[w.nx].tm - v.tm
				end

				if self:IsPrioritized(j) and (w.es == "Constant" or inst --[[or not w.pv or tm <= ins_thres]]) then
					if self:IsPrioritized(j) and (inst --[[or not w.pv or tm <= ins_thres]]) then
						poses[j] = cf
						break
					end

					local t = 0
					local ntm = (tm / speed)

					coroutine.wrap(function()

						repeat
							poses[j] = cf
							t = t + twait()
						until t >= ntm
					end)()

					break
				end

				if not enumExists("EasingStyle", w.es) then
					w.es = "Linear"
				end

				coroutine.wrap(function()
					local t = 0
					local ntm = (tm / speed)
					local current = poses[j]
					local es, ed = Enum.EasingStyle[w.es], Enum.EasingDirection[w.ed]

					repeat
						local cf = current:Lerp(cf, tween:GetValue(
							min(t / ntm, 1), es, ed
						))

						local alpha = min(self.lerpFactor * max(1, speed), 1)

						if self:IsPrioritized(j) then
							if alpha < 1 then
								poses[j] = poses[j]:Lerp(cf, alpha)
							else
								poses[j] = cf
							end
						end

						t = t + twait()
					until t >= ntm
				end)()
			until true

			if br then
				break
			end
		end
	end

	function AnimationTrack.Play(self, speed)
		assert(self.Rig, "Must use setRig before playing!")

		speed = speed or self.Speed

		if self.IsPlaying then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end
		end

		self.Speed = speed
		self.IsPlaying = true
		self.Weight = self.RealWeight

		self.TimePosition = 0

		-- // just loop through all the keyframes instantly if speed is too high since it'll break
		if false then
			coroutine.wrap(function()
				repeat
					twait()

					for _, v in ipairs(self.Animation) do
						self:goToKeyframe(v, true)
						self.TimePosition = self.TimePosition + v.tm
					end

					self.TimePosition = self.Length
					task.wait(self.Stall)
				until not self.Looped

				self:Stop()
			end)()

			return
		end

		if self.RootMotion then
			self.LastRootTransform = CFrame.identity
		end

		coroutine.wrap(function()
			repeat
				self.TimePosition = 0
				
				for i, v in ipairs(self.Animation) do
					local cnt
					local total = 0
					local time = v.tm

					cnt = game:GetService("RunService").PostSimulation:Connect(function(dt)
						total = total + (dt * self.Speed)
						
						if total >= time then
							cnt:Disconnect()
							self:goToKeyframe(v)
						end
					end)

					insert(self.Connections, cnt)
				end

				repeat
					self.TimePosition = self.TimePosition + (twait() * self.Speed)
				until self.TimePosition >= (self.Length + (self.Looped and 0 or self.Stall)) or not self.IsPlaying

				if self.TimePosition >= self.Length and not self.Looped then
					self:Stop()
				end

				if self.Looped then
					self.DidLoop:Fire()
				end
			until not self.Looped or not self.IsPlaying
		end)()
	end

	function AnimationTrack.Stop(self)
		if not self.IsPlaying then
			return
		end

		self.Stopped:Fire()

		self.Weight = 0
		self.IsPlaying = false
		self.TimePosition = self.Length
		
		if self.Connections then
			for _, cnt in pairs(self.Connections) do
				cnt:Disconnect()
			end
		end
		
		local main = AnimationTrack.Rigs[self.Rig]

		if self.RootMotion and main and main.Poses then
			for _ = 1, 1000 do
				main.Poses[self.RootMotion] = CFrame.identity
			end
		end
	end

	function AnimationTrack.AdjustSpeed(self, speed)
		self.Speed = speed or 1
	end
end

return AnimationTrack
